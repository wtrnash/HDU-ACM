/************************************************************************************************
Problem Description
人称“AC女之杀手”的超级偶像LELE最近忽然玩起了深沉，这可急坏了众多“Cole”（LELE的粉丝,即可乐）,
经过多方打探，某资深Cole终于知道了原因，原来，LELE最近研究起了著名的RPG难题:
有排成一行的ｎ个方格，用红(Red)、粉(Pink)、绿(Green)三色涂每个格子，每格涂一色，要
求任何相邻的方格不能同色，且首尾两格也不同色．求全部的满足要求的涂法.
以上就是著名的RPG难题.如果你是Cole,我想你一定会想尽办法帮助LELE解决这个问题的;
如果不是,看在众多漂亮的痛不欲生的Cole女的面子上,你也不会袖手旁观吧?
Input
输入数据包含多个测试实例,每个测试实例占一行,由一个整数N组成，(0<n<=50)。
Output
对于每个测试实例，请输出全部的满足要求的涂法，每个实例的输出占一行。
Sample Input
1
2
Sample Output
3
6
***********************************************************************************************/
//递推求解，除了前三个格子，第四个格子开始，第i个格子的涂法可以分两种情况来加
//如果i-1个格子都合法，那总共有f(i-1)种涂法，这个时候第i个格子不能和前一个以及第一个格子一样，
//所以总共1 * f(i-1)个涂法； 
//第二种情况如果i-1个不合法，即首尾一样，这个时候第i个格子可以涂两种颜色。
//而i-1个不合法的情况其实就是i-2个合法的情况加上第i-1个格子和第一个格子颜色一样，
//所以这个情况总共有 2 * f(i - 2)个涂法
//总共就是 f(i - 1 ) + 2 * f(i-2)个涂法
//通过打表来做，还是要用long long，用int会溢出 
#include <iostream>
using namespace std;

int main()
{
	long long f[51];
	f[1] = 3;
	f[2] = 6;
	f[3] = 6;
	for(int i = 4; i < 51; i++)
	{
		f[i] = f[i - 1] + 2 * f[i - 2];
	}
	
	int n;
	while(cin >> n)
	{
		cout << f[n] << endl;
	}
	
	return 0;	
} 
