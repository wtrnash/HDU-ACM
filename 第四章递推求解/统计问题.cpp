/********************************************************************************************************
Problem Description
在一无限大的二维平面中，我们做如下假设：
1、每次只能移动一格；
2、不能向后走（假设你的目的地是“向上”，那么你可以向左走，可以向右走，也可以向上走，但是不可以向下走）；
3、走过的格子立即塌陷无法再走第二次；
求走n步不同的方案数（2种走法只要有一步不一样，即被认为是不同的方案）。
Input
首先给出一个正整数C，表示有C组测试数据
接下来的C行，每行包含一个整数n (n<=20)，表示要走n步。
Output
请编程输出走n步的不同方案总数；每组的输出占一行。
Sample Input
2
1
2
Sample Output
3
7
*********************************************************************************************************/ 
//递推求解。将第i步走的路径数分成最后一步是横走还是竖走的。
//倒数第二步无论是横走还是竖走，最后一步都能竖走，
//而如果最后一步是横走的，则倒数第二步竖走时，最后一步可以往左或往右横走
//而倒数第二步是横走时，最后一步只能往一个方向横走
//通过打表来解决问题。 
#include <iostream>
using namespace std;

int main()
{
	long long f[21] = {0, 3};	//总共路径数 
	long long horizontal[21] = {0, 2};	//最后一步横走的路径数
	long long vector[21] = {0, 1}; //最后一步竖走的路径数 
	for(int i = 2; i < 21; i++)
	{
		vector[i] = f[i - 1];	//无论前一步是横走还是竖走，这一步一定能竖走
		horizontal[i] =  2 * vector[i - 1]  + horizontal[i - 1];     //前一步如果是竖走，那这一步能往两边横走；前一步如果是横走，那这一步只能往一边横走 
		f[i] = vector[i] + horizontal[i];
	} 
	int c, n;
	cin >> c;
	while(c--)
	{
		cin >> n;
		cout << f[n] << endl;
	}
	
	return 0;
}
