/*************************************************************************************************
Problem Description
“今年暑假不AC？”
“是的。”
“那你干什么呢？”
“看世界杯呀，笨蛋！”
“@#$%^&*%...”
确实如此，世界杯来了，球迷的节日也来了，估计很多ACMer也会抛开电脑，奔向电视了。
作为球迷，一定想看尽量多的完整的比赛，当然，作为新时代的好青年，你一定还会看一些其它的节目，
比如新闻联播（永远不要忘记关心国家大事）、非常6+7、超级女生，以及王小丫的《开心辞典》等等，
假设你已经知道了所有你喜欢看的电视节目的转播时间表，你会合理安排吗？（目标是能看尽量多的完整节目）
Input
输入数据包含多个测试实例，每个测试实例的第一行只有一个整数n(n<=100)，表示你喜欢看的节目的总数，
然后是n行数据，每行包括两个数据Ti_s,Ti_e (1<=i<=n)，分别表示第i个节目的开始和结束时间，
为了简化问题，每个时间都用一个正整数表示。n=0表示输入结束，不做处理。
Output
对于每个测试实例，输出能完整看到的电视节目的个数，每个测试实例的输出占一行。
Sample Input
12
1 3
3 4
0 7
3 8
15 19
15 20
10 15
8 18
6 12
5 10
4 14
2 9
0
Sample Output
5
****************************************************************************************************/
//简单的贪心算法题，因为所有含节目数最多的序列中一定有至少一个序列是包含结束时间最早的节目的，
//所以将节目按结束时间早晚排序，第一个节目算可以看，然后后面的节目的开始时间和第一个节目的结束时间进行比较，
//如果比前一个节目的结束时间要晚，则该节目也可以看，计数加一，以此类推即可。 
#include <iostream>
#include <vector>
#include <algorithm>

using namespace std;

struct TV
{
	int start;
	int end;	
};

bool compare(TV tv1, TV tv2)		//按结束时间早晚排序 
{
	return tv1.end < tv2.end;
}

int main()
{
	int n;
	TV temp;
	vector<TV> v;
	int count;
	cin >> n;
	while(n != 0)
	{
		v.clear();
		count = 0;
		for(int i = 0; i < n; i++)	//读取数据，存入向量 
		{
			cin >> temp.start >> temp.end;
			v.push_back(temp);
		}
		
		sort(v.begin(), v.end(), compare);	//排序 
		if(v.size())		//如果不为空，则第一个节目一定可以看，所以count+1,temp记录为第一个节目 
		{
			count++;
			temp = v[0]; 
		}
			
		for(int i = 1; i < v.size(); i++)
		{
			if(v[i].start >= temp.end)		//当前节目的开始时间和上一个节目的结束时间进行比较，如果开始时间晚，则可以看，计数+1，将temp设为当前节目，否则不做操作 
			{
				count++;
				temp = v[i];
			}
		}
		cout << count << endl;		//输出结果 
		cin >> n;
	}
	
	return 0;
}
