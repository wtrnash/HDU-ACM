/*********************************************************************************************************************************************************************
Problem Description
本次集训队共有30多人参加，毫无疑问，你们都是很优秀的，但是由于参赛名额有限，只能选拔部分队员参加省赛。
从学校的角度，总是希望选拔出最优秀的18人组成6支队伍来代表学校。但是，大家也知道，要想做到完全客观，是一件很难的事情。因为选拔的标准本身就很难统一。
为了解决这个难题，我现在把问题作了简化，现在假设每个队员都是二维平面中的一个点，用(xi,yi)坐标来表示，一个队员的能力可以用他到原点的欧几里德距离来表示。
由于这种排名标准太~客观了，新队员很难有出头的机会，很多人很是郁闷。特别是一个废话不是很多、不是特别暴躁、号称盖帽高手的伪**就很有意见，
他现在要求改革排名规则，并且自己提出了一套号称绝对公正的方案：现在不是用一个点来表示一个队员了，而是用原点到该队员所在的点所构成的向量来表示一个队员。
如果该向量和X正轴夹角比较小的话，就说他的能力比较高，排名就应该靠前。<br>这就是著名的“伪氏规则”（说实话，这规则我有点怀疑其客观性，因为我知道他的坐标是(3.1,0.1)...）
Input
输入数据包含多组测试实例，每个实例的第一行是一个整数n（n<=100）,表示集训队员的人数，紧接着的一行是2*n个数，
表示n个队员的坐标值（x1,y1,x2,y2...xn,yn），n为负数的时候表示输入数据的结束。特别说明，所有的y坐标均为正数，并且所有的坐标值都是有一位小数的浮点数。
Output
对于每个测试实例，请在一行内输出排名后的坐标，坐标之间用一个空格隔开。特别地，你可以假设根据“伪氏排名规则”结果唯一.
Sample Input
3
5.0 4.0 3.1 0.1 2.0 2.0
-1
Sample Output
3.1 0.1 5.0 4.0 2.0 2.0
************************************************************************************************************************************************************************/
//利用叉乘来判断向量间顺逆时针关系，如果叉乘为正，说明前一个向量在后一个向量的顺时针方向，也就是和x正轴夹角比较小
//通过排序后输出结果即可 
#include <iostream>
#include <algorithm>
#include <iomanip>
using namespace std;

struct Point
{
	double x;
	double y;
 }points[101];

double crossProduct(double x1, double y1, double x2, double y2)	//叉乘 
{
	return x1 * y2 - x2 * y1; 
}

bool compare(Point p1, Point p2)	//利用叉乘判断两个向量的位置关系，如果p1和p2叉乘为正，说明p1在p2的顺时针方向，也就是p1和x正方向的角度小，所以排在前 
{
	if(crossProduct(p1.x, p1.y, p2.x, p2.y) > 0)
		return true;
	else
		return false;	
}

int main()
{
	int n;
	cin >> n;
	while(n >= 0)
	{
		for(int i = 0;i < n; i++)
		{
			cin >> points[i].x >> points[i].y;
		}
		
		sort(points, points + n, compare);	//排序 
		if(n != 0)	//为了处理空格，先单独输出第一个点的坐标 
		{
			cout << fixed << setprecision(1) << points[0].x << " " << points[0].y;
		}
		
		for(int i = 1; i < n; i++)
		{
			cout <<  fixed << setprecision(1) << " " << points[i].x << " " << points[i].y;
		}
		cout << endl;
		cin >> n;
	}
	return 0;
}
