/***************************************************************************************************************************
Problem Description
急！灾区的食物依然短缺！
为了挽救灾区同胞的生命，心系灾区同胞的你准备自己采购一些粮食支援灾区，
现在假设你一共有资金n元，而市场有m种大米，每种大米都是袋装产品，其价格不等，并且只能整袋购买。
请问：你用有限的资金最多能采购多少公斤粮食呢？
后记：
人生是一个充满了变数的生命过程，天灾、人祸、病痛是我们生命历程中不可预知的威胁。
月有阴晴圆缺，人有旦夕祸福，未来对于我们而言是一个未知数。那么，我们要做的就应该是珍惜现在，感恩生活――
感谢父母，他们给予我们生命，抚养我们成人；
感谢老师，他们授给我们知识，教我们做人
感谢朋友，他们让我们感受到世界的温暖；
感谢对手，他们令我们不断进取、努力。
同样，我们也要感谢痛苦与艰辛带给我们的财富～
Input
输入数据首先包含一个正整数C，表示有C组测试用例，每组测试用例的第一行是两个整数n和m(1<=n<=100, 1<=m<=100),
分别表示经费的金额和大米的种类，然后是m行数据，每行包含3个数p，h和c(1<=p<=20,1<=h<=200,1<=c<=20)，
分别表示每袋的价格、每袋的重量以及对应种类大米的袋数。
Output
对于每组测试数据，请输出能够购买大米的最多重量，你可以假设经费买不光所有的大米，并且经费你可以不用完。每个实例的输出占一行。
Sample Input
1
8 2
2 100 4
4 100 2
Sample Output
400
******************************************************************************************************************************/

#include <iostream>
#include <algorithm>
using namespace std;

int weight[1001];
int value[1001];
int dp[1001];

int main()
{
	int c, n, m, w, v, num, cnt;
	cin >> c;
	while(c--)
	{
		cnt = 0;
		cin >> n >> m;
		for(int i = 0; i < m; i++)
		{
			cin >> v >> w >> num;
			//用二进制法拆分，将n件物品拆成为系数为1,2, 4, ……, 2^(k-1),n[i]-2^k+1 的若干件物品，再用01背包做即可 
			int t = 1;
			while (num >= t) 
			{
				value[cnt] = v * t;
				weight[cnt++] = w * t;
				num -= t;
				t <<= 1;
			}
			if (num) 
			{
				value[cnt] = v * num;
				weight[cnt++] = w * num;
			}
		}
		
		fill(dp, dp + 1001, 0);
		for(int i = 0; i < cnt; i++)
		{
			for(int j = n; j >= value[i]; j--)
			{
				dp[j] = max(dp[j], dp[j - value[i]] + weight[i]);
			}
		}
		
		cout << dp[n] << endl;
	}
	return 0;
} 
