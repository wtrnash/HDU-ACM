/***********************************************************************************************************
Problem Description
HOHO，终于从Speakless手上赢走了所有的糖果，是Gardon吃糖果时有个特殊的癖好，就是不喜欢将一样的糖果放在一起吃，
喜欢先吃一种，下一次吃另一种，这样；可是Gardon不知道是否存在一种吃糖果的顺序使得他能把所有糖果都吃完？
请你写个程序帮忙计算一下。
Input
第一行有一个整数T，接下来T组数据，每组数据占2行，第一行是一个整数N（0<N<=1000000)，第二行是N个数，
表示N种糖果的数目Mi(0<Mi<=1000000)。
Output
对于每组数据，输出一行，包含一个"Yes"或者"No"。
Sample Input
2
3
4 1 1
5
5 4 3 2 1
Sample Output
No
Yes
*************************************************************************************************************/ 
//思路就是记录糖果的数目总和以及数量最多的糖果数量，如果数量最多的糖果数量刚刚好比剩下的糖果数要大1，那正好可以将所有其他糖果都插在数量最多的糖果之间，保证存在吃糠顺序，
//而如果最多的糖果数量比剩下糖果数量多的部分大于1，就一定会存在两颗一样的糖果挨着了，这就是核心判断条件。
//要注意用long long来存储和，只用int的话sum可能超过int的范围导致不能AC 
#include <iostream>
using namespace std;

int main()
{
	int t, n;
	long long sum, max, temp;
	cin >> t;
	for(int i = 0; i < t; i++)
	{
		cin >> n;
		sum = 0;
		max = 0;
		for(int j = 0; j < n; j++)
		{
			cin >> temp;
			if(temp > max)
				max = temp;				//记录最多的糖果数量 
			sum += temp;				//记录糖果数量总和 
		}
		if(max > sum - max + 1)			//如果数量最多的糖果数量比剩下的数量还要大1以上则找不到吃糖顺序 
			cout << "No" << endl;
		else
			cout << "Yes" << endl;
	}
	return 0;
}
