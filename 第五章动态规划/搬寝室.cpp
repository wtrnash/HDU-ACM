/*************************************************************************************************************************************
Problem Description
搬寝室是很累的,xhd深有体会.时间追述2006年7月9号,那天xhd迫于无奈要从27号楼搬到3号楼,因为10号要封楼了.
看着寝室里的n件物品,xhd开始发呆,因为n是一个小于2000的整数,实在是太多了,于是xhd决定随便搬2*k件过去就行了.
但还是会很累,因为2*k也不小是一个不大于n的整数.幸运的是xhd根据多年的搬东西的经验发现每搬一次的疲劳度是和左右手的物品的重量差的平方成正比
(这里补充一句,xhd每次搬两件东西,左手一件右手一件).例如xhd左手拿重量为3的物品,右手拿重量为6的物品,则他搬完这次的疲劳度为(6-3)^2 = 9.
现在可怜的xhd希望知道搬完这2*k件物品后的最佳状态是怎样的(也就是最低的疲劳度),请告诉他吧.
Input
每组输入数据有两行,第一行有两个数n,k(2<=2*k<=n<2000).第二行有n个整数分别表示n件物品的重量(重量是一个小于2^15的正整数).
Output
对应每组输入数据,输出数据只有一个表示他的最少的疲劳度,每个一行.
Sample Input
2 1
1 3
Sample Output
4
***************************************************************************************************************************************/ 
//首先要明确，一定是拿相邻的物品疲劳值会最小
//在这个基础上对物品重量进行排序
//i个物品选j对的最小值 就是在 （i - 1个物品里选j对） 以及 （在 i-2个物品里选 j - 1对  加上 第i个物品和 i - 1个物品相配对） 的最小值
//最后选出 n个物品选K对的最小值即可 
#include <iostream>
#include <algorithm>
using namespace std;

int dp[2002][2002];	//dp[i][j]表示 i个物品里选j对的最小疲劳值 
int main()
{
	int n, k;
	int weight[2002];

	while(cin >> n >> k)
	{
		for(int i = 0; i < n; i++)
		{
			cin >> weight[i];
		}
		
		for(int i = 0; i <= n; i++)		//i个物品选0对疲劳值为0 
			dp[i][0] = 0;	
		
		for(int i = 0; i <= n; i++)
		{
			for(int j = 1; j <= k; j++)
				dp[i][j] = INT_MAX;			//初始化为最大值	
		}
		
		sort(weight, weight + n);	//升序排序
		
		for(int i = 2; i <= n; i++)
		{
			for(int j = 1; j <= i/2 && j <= k; j++)
			{
				dp[i][j] = min(dp[i - 1][j], dp[i - 2][j - 1] + (weight[i - 1] - weight[i - 2]) * (weight[i - 1] - weight[i - 2]));	
			}	
		} 
		
		cout << dp[n][k] << endl;
	}
	return 0;
}
