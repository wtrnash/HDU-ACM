/************************************************************************************************************************************************
Problem Description
都说天上不会掉馅饼，但有一天gameboy正走在回家的小径上，忽然天上掉下大把大把的馅饼。
说来gameboy的人品实在是太好了，这馅饼别处都不掉，就掉落在他身旁的10米范围内。
馅饼如果掉在了地上当然就不能吃了，所以gameboy马上卸下身上的背包去接。
但由于小径两侧都不能站人，所以他只能在小径上接。
由于gameboy平时老呆在房间里玩游戏，虽然在游戏中是个身手敏捷的高手，但在现实中运动神经特别迟钝，每秒种只有在移动不超过一米的范围内接住坠落的馅饼。
现在给这条小径如图标上坐标：
为了使问题简化，假设在接下来的一段时间里，馅饼都掉落在0-10这11个位置。
开始时gameboy站在5这个位置，因此在第一秒，他只能接到4,5,6这三个位置中其中一个位置上的馅饼。
问gameboy最多可能接到多少个馅饼？（假设他的背包可以容纳无穷多个馅饼）
Input
输入数据有多组。每组数据的第一行为以正整数n(0<n<100000)，表示有n个馅饼掉在这条小径上。
在结下来的n行中，每行有两个整数x,T(0<T<100000),表示在第T秒有一个馅饼掉在x点上。
同一秒钟在同一点上可能掉下多个馅饼。n=0时输入结束。
Output
每一组输入数据对应一行输出。输出一个整数m，表示gameboy最多可能接到m个馅饼。 
提示：本题的输入数据量比较大，建议用scanf读入，用cin可能会超时。
Sample Input
6
5 1
4 1
6 1
7 2
7 2
8 3
0
Sample Output
4
****************************************************************************************************************************************************/
//动态规划，实质上还是数塔问题，某个点当前时刻能获得的最大饼数等于之后时间能获得的最大饼数加上当前的，所以要从最后开始由底向上进行求和
//求出最后时刻每个点落的饼，前一时刻除了第0点和第10点，其他点能落的最大的饼等于当前时刻落的饼加上后一时刻左中右三个点中落饼最多的
//第0点则是0,1两个点后一时刻落饼最多的，第10点是9,10两个点后一时刻落饼最多的
//以此类推，一直计算到最开始，求出第五个点最开始能获得的最多饼即可 
//数组过大需要放在函数外，放在函数内会栈溢出。然后要注意虽然说T题目上说是0 < T < 100000,但如果数组只开到100000还是会WA,需要开到100001 
#include <cstdio>
#include <algorithm>
using namespace std; 
int cake[100001][11];	//记录每个时刻每个点的饼数 ,放在主函数中会显示栈溢出
 
int main()
{
	int n, x, t;
	int last; 				//记录最后落饼的时刻 
 

	scanf("%d", &n);
	while(n != 0)
	{
		last = 0;
		fill(cake[0], cake[0] + 11 * 100001, 0);	//填0 
		for(int i = 0; i < n; i++)
		{
			scanf("%d%d", &x, &t);
			cake[t][x]++;	//该时刻该点落的饼数加一 
			if(t > last)
				last = t;
		}
		
		for(int i = last - 1; i >= 0; i--)	//从最后落饼的时刻开始往前，算出每个时刻每个点最多可能捡到的饼 
		{
			cake[i][0] += max(cake[i + 1][0], cake[i + 1][1]);  //单独处理第0点，因为第0点左边没有点了 
			  
			for(int j = 1; j < 10; j++)
			{
				cake[i][j] += max(max(cake[i + 1][j - 1], cake[i + 1][j]), cake[i + 1][j + 1]);
			}
			
			cake[i][10] += max(cake[i + 1][9], cake[i + 1][10]);	//单独处理第10点，因为第10点右边没有点了 
		} 
		
		printf("%d\n", cake[0][5]); 	//最后输出0时刻，第5个位置也就是起始位置的最大饼数 
		
		scanf("%d", &n);
	}
	return 0;	
} 
