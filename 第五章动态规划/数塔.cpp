/*************************************************************************************************************
Problem Description
在讲述DP算法的时候，一个经典的例子就是数塔问题，它是这样描述的：
有如下所示的数塔，要求从顶层走到底层，若每一步只能走到相邻的结点，则经过的结点的数字之和最大是多少？
已经告诉你了，这是个DP的题目，你能AC吗?
Input
输入数据首先包括一个整数C,表示测试实例的个数，每个测试实例的第一行是一个整数N(1 <= N <= 100)，表示数塔的高度，
接下来用N行数字表示数塔，其中第i行有个i个整数，且所有的整数均在区间[0,99]内。
Output
对于每个测试实例，输出可能得到的最大和，每个实例的输出占一行。
Sample Input
1
5
7
3 8
8 1 0 
2 7 4 4
4 5 2 6 5
Sample Output
30
****************************************************************************************************************/
//动态规划，从底往上，求出最底下的每两个的最大和，然后一直往上计算即可。这样避免了重复计算
//用二维数组来读取数据 
#include <iostream>
#include <algorithm> 
using namespace std;

int main()
{
	int tower[101][101];
	int maxSum[101][101];
	int c, n;
	cin >> c;
	while(c--)
	{
		cin >> n;
		for(int i = 1; i <= n; i++)		//读入数据 
		{
			for(int j = 1; j <= i; j++)
				cin >> tower[i][j];
		}
		
		//填充最后一层
		for(int i = 1; i <= n; i++)
			maxSum[n][i] = tower[n][i]; 
		
		//计算每层选择最大路径时的最大和 
		for(int i = n - 1; i >= 1; i--)
		{
			for(int j = 1; j <= i; j++)
			{
				maxSum[i][j] =  max(maxSum[i + 1][j], maxSum[i + 1][j + 1]) + tower[i][j];  	//下层选取两个中的较大值加上本身 
			}
		}
		
		cout << maxSum[1][1] << endl;			
	}
	return 0;	
} 
